#!/bin/sh

PROGNAME="${0##*/}"
VERSION="v0.1.0"
GPP_BIN="${GPGCACHE_GPP_BIN:-/usr/lib/gnupg/gpg-preset-passphrase}"
ALLOW_SSH_KEY_TEST=""
TMPDIR="${TMPDIR:-"${XDG_RUNTIME_DIR}"}"
randstr() { tr -dc "[:alnum:]" </dev/urandom | dd count=1 bs=12 2>/dev/null; }
[ -d "${TMPDIR}" ] \
  && TMPDIR="${TMPDIR}/gpgcacher.$(randstr)" \
  || TMPDIR="/dev/shm/gpgcacher.$(randstr)"

#
# Error Codes
#
SHELL_STD_ERR=1
GPG_SIGN_FAIL=$((SHELL_STD_ERR + 1))
GPG_ENC_FAIL=$((GPG_SIGN_FAIL + 1))
GPG_DEC_FAIL=$((GPG_ENC_FAIL + 1))
GPG_KEY_NOT_FOUND=$((GPG_DEC_FAIL + 1))
GPG_AGENT_FAIL=$((GPG_KEY_NOT_FOUND + 1))
GPG_AGENT_NO_CACHE=$((GPG_AGENT_FAIL + 1))
GPP_FAIL=$((GPG_AGENT_FAIL + 1))
GPG_EXP_SSH_FAIL=$((GPP_FAIL + 1))
SSH_ADD_TEST_FAIL=$((GPG_EXP_SSH_FAIL + 1))

#
# Instead of creating a different error code for each gpg-connect-agent error,
# have one (GPG_AGENT_FAIL) and save its error message to be used with `warn()`.
# The same applies to gpg-preset-passphrase.
#
GPG_AGENT_ERRMSG=""
GPP_ERRMSG=""

#
# Warn the user through stderr with a short one line message.
# Globals
#   PROGNAME
# Parameters:
#   1: error code.
#
warn() {
  printf "%s: %s\n" "${PROGNAME}" "${1}" 1>&2
}

#
# Print to stdout a '\n' separated list of keytype, key fingerprint and
# keygrip of the sub keys.
# Globals:
#   GPG_KEY_NOT_FOUND
# Parameters:
#   1: key-id.
# Returns:
#   0, when successful;
#   GPG_KEY_NOT_FOUND, when gpg fails to find the given key-id.
#
print_trios() {
  unset gpg_output
  gpg_output="$(gpg --list-secret-keys --with-keygrip --with-colons "${1}")" \
    || return "${GPG_KEY_NOT_FOUND}"

  unset passed_uid_line keytype keyfpr keygrip
  while IFS=":" read -r infotype info; do
    case "${infotype}" in
      uid)
        passed_uid_line="1"
        continue
        ;;
    esac

    [ -z "${passed_uid_line}" ] && continue

    case "${infotype}" in
      ssb)
        keytype="${info%+*}"
        keytype="${keytype%:::}"
        keytype="${keytype##*:}"
        ;;
      fpr)
        keyfpr="${info%:}"
        keyfpr="${keyfpr##*:}"
        ;;
      grp)
        keygrip="${info%:}"
        keygrip="${keygrip##*:}"
        printf "%s,%s,%s\n" "${keytype}" "${keyfpr}" "${keygrip}"
        unset keytype keyfpr keygrip
        ;;
    esac
  done <<EOF
$(printf "%s\n" "${gpg_output}")
EOF

  return 0
}

#
# Cache a given sub key.
#
# Globals:
#   GPG_AGENT_FAIL
#   GPP_FAIL
#   GPP_ERRMSG
#   GPG_AGENT_ERRMSG
#
# Parameters:
#   1: keygrip; and
#   2: passphrase command (optional).
#
# Returns:
#   0, when successful;
#   GPP_FAIL, when gpg-preset-passphrase fails.
#   GPG_AGENT_FAIL, when gpg-connect-agent fails.
#
cache_key() {
  if [ -z "${2}" ]; then
    unset gpg_agent_output
    gpg_agent_output="$(
      gpg-connect-agent <<EOF
GET_PASSPHRASE ${1} + Passphrase:+ No+passcmd+provide.+A+passphrase+is+needed.
EOF
)"
    case "${gpg_agent_output}" in
      ERR*)
        GPG_AGENT_ERRMSG="${gpg_agent_output}"
        unset gpg_agent_output
        return "${GPG_AGENT_FAIL}"
        ;;
    esac

    unset gpg_agent_output
  else
    unset gpp_output
    gpp_output="$(
      ${GPP_BIN} --preset "${1}" 2>&1 <<EOF
$(eval "${2}")
EOF
)" || {
  GPP_ERRMSG="${gpp_output}"
  unset gpp_output
  return "${GPP_FAIL}"
}
  fi

  return 0
}

#
# Check if a key in a smartcard is cached by using its keygrip with
# gpg-connect-agent.
# Globals:
#   GPG_AGENT_FAIL
#   GPG_AGENT_NO_CACHE
#   GPG_AGENT_ERRMSG
# Parameters:
#   1: Gpg key.
#
# Returns:
#   0, when successful;
#   GPG_KEY_NOT_FOUND, when gpg does not find the given key;
#   GPG_AGENT_FAIL, when gpg-connect-agent prints an error to stdout;
#   GPG_AGENT_NO_CACHE, when the key is not cached.
#
is_sc_cached() {
  gpg --list-secret-keys "${1}" 1>/dev/null 2>&1 || return "${GPG_KEY_NOT_FOUND}"

  gpg_agent_output="$(gpg-connect-agent "scd getinfo card_list" /bye)"

  case "${gpg_agent_output}" in
    ERR*)
      GPG_AGENT_ERRMSG="${gpg_agent_output}"
      return "${GPG_AGENT_FAIL}"
      ;;
    S[[:space:]]SERIALNO[[:space:]]*) return 0;;
  esac

  return "${GPG_AGENT_NO_CACHE}"
}

#
# Test the encrypt gpg command in non-interactive mode to check if the cached
# password is the correct one.
#
# Globals:
#   GPG_ENC_FAIL
#   GPG_DEC_FAIL
#
# Parameters:
#   1: key type;
#   2: key fingerprint.
#
# Returns:
#   0, when successful;
#   GPG_ENC_FAIL, when gpg fails to encrypt its stdin;
#   GPG_DEC_FAIL, when gpg fails do decrypt its stdin.
is_passphrase_correct() {
  case "${1}" in
    e)
      unset gpg_output
      gpg_output="$(
        printf "\n" \
          | gpg --armor -o- \
            --no-options --yes --batch --pinentry-mode loopback \
            --encrypt --recipient "${2}" 2>/dev/null
      )" || return "${GPG_ENC_FAIL}"

      printf "%s" "${gpg_output}" \
        | gpg -o /dev/null \
          --no-options --yes --batch --pinentry-mode loopback \
          --decrypt --default-key "${2}" 2>/dev/null \
        || return "${GPG_DEC_FAIL}"
      ;;
    s)
      printf "\n" \
        | gpg -o /dev/null \
          --no-options --yes --batch --pinentry-mode loopback \
          --sign --local-user "${2}" 2>/dev/null \
        || return "${GPG_SIGN_FAIL}"
      ;;
    a)
      [ -z "${ALLOW_SSH_KEY_TEST}" ] && return 0
      unset ssh_pub_key
      ssh_pub_key="${TMPDIR}/ssh_pub_key"
      : 1>"${ssh_pub_key}"

      gpg -o "${ssh_pub_key}" --export-ssh-key "${2}" 2>/dev/null \
        || return "${GPG_EXP_SSH_FAIL}"

      ssh-add -T "${ssh_pub_key}" \
        || return "${SSH_ADD_TEST_FAIL}"
      ;;
  esac

  return 0
}

#
# Clear the cached passphrase.
#
# Globals:
#   GPG_AGENT_FAIL
#   GPG_AGENT_ERRMSG
#
# Parameters:
#   1: keygrip.
#
# Returns:
#   0, when successful;
#   GPG_AGENT_FAIL, when gpg-connect-agent fails to clear the cache.
#
clear_cache() {
  unset gpg_agent_output
  gpg_agent_output="$(gpg-connect-agent <<EOF
CLEAR_PASSPHRASE ${1}
EOF
)"
  case "${gpg_agent_output}" in
    OK*) return 0;;
    *)
      GPG_AGENT_ERRMSG="${gpg_agent_output}"
      return "${GPG_AGENT_FAIL}"
      ;;
  esac
}


#
# Print the help message to stdout.
# Globals:
#   PROGNAME
#
help_msg() {
  printf """
  Usage: %s [OPTION]... KEY_ID[:CACHE_OPTS] [KEY_ID[:CACHE_OPTS]]...
  Cache gpg keys.

  -a,\t\tAllow ssh keys cache to be tested
  -g,\t\tSet the path to the gpg-preset-passphrase binary
  -h,\t\tPrint this help message to stdout
  -V,\t\tPrint the script's version

  CACHE_OPTS

  passcmd PASS_CMD,\tUse the stdout of PASS_CMD as the passphrase
  sc,\t\t\tIndicate that the key is in a smartcard

  " "${PROGNAME}"
}

main() {
  mkdir -p "${TMPDIR}"
  trap 'rm -rf "${TMPDIR}"' EXIT INT

  sopts="ag:hV"
  while getopts "${sopts}" opt; do
    case "${opt}" in
      "h")
        help_msg
        exit 0
        ;;
      "a") ALLOW_SSH_KEY_TEST="1" ;;
      "g")
        [ -x "${OPTARG}" ] || {
          warn "\"${OPTARG}\" is not executable."
          exit 1
        }

        GPP_BIN="${OPTARG}"
        ;;
      "V")
        printf "%s %s\n" "${PROGNAME}" "${VERSION}"
        exit 0
        ;;
    esac
  done

  shift $((OPTIND - 1))

  for k in "${@}"; do
    opts="${k##*:}"
    key="${k%":${opts}"}"
    
    if [ "${key}" != "${opts}" ]; then
      passcmd=""
      while IFS= read -r opt; do
          case "${opt}" in
            "passcmd"?*) passcmd="${opt#*[[:space:]]}" ;;
            "sc") cache_check_type="sc" ;;
            *)
              warn "Unknown option \"${opt}\"; skipping \"${key}\"..."
              continue 2
              ;;
          esac
      done <<EOF
$(printf "%s\n" "${opts}" | tr ',' '\n')
EOF
    fi

    unset errcode
    case "${cache_check_type}" in
      "sc")
        is_sc_cached "${key}"
        errcode="${?}"
        ;;
    esac
    case "${errcode}" in
      0)
        warn "Key \"${key}\" is already cached; skipping..."
        continue
        ;;
      "${GPG_KEY_NOT_FOUND}")
        warn "Gpg failed to found key \"${key}\"."
        continue
        ;;
      "${GPG_AGENT_FAIL}")
        warn "gpg-connect-agent error: \"${GPG_AGENT_ERRMSG}\"."
        continue
        ;;
    esac

    while IFS="," read -r keytype keyfpr keygrip; do
      unset errcode
      cache_key "${keygrip}" "${passcmd}"
      errcode="${?}"
      case "${errcode}" in
        "${GPP_FAIL}")
          warn "Key \"${key}\" not cached."
          warn "${GPP_ERRMSG}."
          continue 2
          ;;
        "${GPG_AGENT_FAIL}")
          warn "Key \"${key}\" not cached."
          warn "${GPG_AGENT_ERRMSG}."
          continue 2
          ;;
      esac

      unset errcode
      is_passphrase_correct "${keytype}" "${keyfpr}"
      errcode="${?}"
      if [ "${errcode}" -eq 0 ]; then
          warn "Successfuly cached \"${key}\"."
      else
        warn "Key \"${key}\" not cached."

        case "${errcode}" in
          "${GPG_ENC_FAIL}") warn "Gpg failed to encrypt test message." ;;
          "${GPG_DEC_FAIL}") warn "Gpg failed to decrypt test message." ;;
          "${GPG_SIGN_FAIL}") warn "Gpg failed to sign test message." ;;
          "${GPG_EXP_SSH_FAIL}") warn "Gpg failed to export ssh key." ;;
          "${SSH_ADD_TEST_FAIL}") warn "ssh-add failed to test public key." ;;
        esac

        warn "Clearing wrong password in cache."
        clear_cache "${keygrip}" || {
          warn "Failed to clear wrong password in cache."
          warn "Try to manually clear it by passing \"${key}\" keygrip"
          warn "to the CLEAR_PASSPHRASE command of gpg-connect-agent."
        }

        continue
      fi

    done <<EOF
$(print_trios "${key}")
EOF

  done
}

main "${@}"
