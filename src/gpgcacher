#!/bin/sh

PROGNAME="${0##*/}"
TMPDIR="${TMPDIR:-"${XDG_RUNTIME_DIR}"}"
randstr() { tr -dc "[:alnum:]" </dev/urandom | dd count=1 bs=12 2>/dev/null; }
[ -d "${TMPDIR}" ] \
  && TMPDIR="${TMPDIR}/gpgcacher.$(randstr)" \
  || TMPDIR="/dev/shm/gpgcacher.$(randstr)"

#
# Error Codes
#
SHELL_STD_ERR=1
GPG_SIGN_FAIL=$((SHELL_STD_ERR + 1))
GPG_ENC_FAIL=$((GPG_SIGN_FAIL + 1))
GPG_DEC_FAIL=$((GPG_ENC_FAIL + 1))
GPG_KEY_NOT_FOUND=$((GPG_DEC_FAIL + 1))
GPG_AGENT_FAIL=$((GPG_KEY_NOT_FOUND + 1))
GPG_AGENT_NO_CACHE=$((GPG_AGENT_FAIL + 1))

#
# Instead of creating a different error code for each gpg-connect-agent error,
# have one (GPG_AGENT_FAIL) and save its error message to be used with `warn()`.
#
GPG_AGENT_ERRMSG=""

#
# Warn the user through stderr with a short one line message.
# Globals
#   PROGNAME
# Parameters:
#   1: error code.
#
warn() {
  printf "%s: %s\n" "${PROGNAME}" "${1}" 1>&2
}

#
# Check if a key is cached by using its keygrip with gpg-connect-agent.
# Globals:
#   GPG_AGENT_FAIL
#   GPG_AGENT_NO_CACHE
#   GPG_AGENT_ERRMSG
# Parameters:
#   1: Gpg key.
#
# Returns:
#   0, when successful;
#   GPG_KEY_NOT_FOUND, when gpg does not find the given key;
#   GPG_AGENT_FAIL, when gpg-connect-agent prints an error to stdout;
#   GPG_AGENT_NO_CACHE, when the key is not cached.
#
is_cached() {
  gpg_output="$(gpg --with-keygrip --list-secret-keys --with-colons "${1}")" \
    || return "${GPG_KEY_NOT_FOUND}"

  keygrips=""
  while read -r line; do
    case "${line}" in
      grp*)
        kg="${line%:}"
        kg="${kg##*:}"
        keygrips="${keygrips} ${kg}"
        ;;
      *) continue ;;
    esac
  done <<EOF
  $(printf "%s\n" "${gpg_output}") 
EOF

  for kg in ${keygrips}; do
    gpg_agent_output="$(gpg-connect-agent "keyinfo ${kg}" /bye)"

    case "${gpg_agent_output}" in
      ERR*)
        GPG_AGENT_ERRMSG="${gpg_agent_output}"
        return "${GPG_AGENT_FAIL}"
        ;;
      OK*) continue ;;
      *)
        cache_char="${gpg_agent_output#*D - - }"
        cache_char="${cache_char%% *}"
        #
        # Do string comparison, for the other possible result is a '-'.
        #
        [ "${cache_char}" = "1" ] && return 0
        ;;
    esac
  done

  return "${GPG_AGENT_NO_CACHE}"
}

#
# Cache a gpg key by making it sign a newline that's outputted to /dev/null.
# Globals:
#   GPG_SIGN_FAIL
# Parameters:
#   1: Gpg key, 2: A password command (optional).
# Returns:
#   0, when successful;
#   GPG_SIGN_FAIL, when gpg fails to sign.
#
cache_sign() {
  pass_cmd="${2}"
  if [ -z "${pass_cmd}" ]; then
    printf "\n" \
      | gpg -o /dev/null --no-options --use-agent --no-tty --sign --local-user "${1}" \
        2>/dev/null || return "${GPG_SIGN_FAIL}"
  else
    data_file="${TMPDIR}/data_file"
    printf "\n" 1>"${data_file}"

    gpg -o /dev/null \
      --no-options --use-agent --no-tty \
      --batch --pinentry-mode loopback --passphrase-fd 0 \
        --sign --local-user \
        "${1}" "${data_file}" 2>/dev/null <<EOF || return "${GPG_SIGN_FAIL}"
$(eval "${pass_cmd}")
EOF
  fi

  return 0
}

#
# Cache a gpg key by making it encrypt and decrypt, respectively, stdout and
# stdin.
# Globals:
#   GPG_ENC_FAIL
#   GPG_DEC_FAIL
# Parameters:
#   1: Gpg key, 2: A password command (optional).
# Returns:
#   0, when successful;
#   GPG_ENC_FAIL, when gpg fails to encrypt;
#   GPG_DEC_FAIL, when gpg fails to decrypt.
# 
cache_nosign() {
  pass_cmd="${2}"
  encstr="$(
    printf "GPG" \
      | gpg --armor -o- --encrypt \
        --no-options --use-agent --no-tty --recipient "${1}" 2>/dev/null
  )" || return "${GPG_ENC_FAIL}"

  if [ -z "${pass_cmd}" ]; then
    printf "%s" "${encstr}" \
      | gpg -o /dev/null --decrypt \
        --no-options --use-agent --no-tty --default-key "${1}" 2>/dev/null \
        || return "${GPG_DEC_FAIL}"
  else
    data_file="${TMPDIR}/data_file"
    printf "%s" "${encstr}" 1>"${data_file}"
    gpg -o /dev/null --decrypt \
      --no-options --use-agent --no-tty \
      --batch --pinentry-mode loopback --passphrase-fd 0 \
      --default-key "${1}" "${data_file}" \
      2>/dev/null <<EOF || return "${GPG_DEC_FAIL}"
$(eval "${pass_cmd}")
EOF
  fi

  return 0
}

#
# Print the help message to stdout.
# Globals:
#   PROGNAME
#
help_msg() {
  printf """
  Usage: %s [OPTION]... KEY_ID[:CACHE_OPTS] [KEY_ID[:CACHE_OPTS]]...
  Cache gpg keys.

  -h,\t\tPrint this help message to stdout.

  " "${PROGNAME}"
}

main() {
  mkdir -p "${TMPDIR}"
  trap 'rm -rf "${TMPDIR}"' EXIT INT

  sopts="h"
  while getopts "${sopts}" opt; do
    case "${opt}" in
      "h")
        help_msg
        exit 0
        ;;
    esac
  done

  shift $((OPTIND - 1))

  for k in "${@}"; do
    opts="${k##*:}"
    key="${k%":${opts}"}"

    is_cached "${key}"
    errcode="${?}"
    case "${errcode}" in
      0)
        warn "Key \"${key}\" is already cached; skipping..."
        continue
        ;;
      "${GPG_KEY_NOT_FOUND}")
        warn "Gpg failed to found key \"${key}\"."
        continue
        ;;
      "${GPG_AGENT_FAIL}")
        warn "gpg-connect-agent error: \"${GPG_AGENT_ERRMSG}\"."
        continue
        ;;
    esac
    
    cache_cmd=""
    while IFS= read -r opt; do
      if [ "${key}" != "${opt}" ]; then
        case "${opt}" in
          "nosign") cache_cmd="cache_nosign ${key} ${cache_cmd}" ;;
          "passcmd"?*) cache_cmd="${cache_cmd} \"${opt#*[[:space:]]}\"" ;;
          *)
            warn "Unknown option \"${opt}\"; skipping \"${key}\"..."
            continue 2
            ;;
        esac
      fi
    done <<EOF
$(printf "%s\n" "${opts}" | tr ',' '\n')
EOF

    case "${cache_cmd}" in
      cache_*) ;;
      *) cache_cmd="cache_sign ${key} ${cache_cmd}"
    esac

    eval "${cache_cmd}"
    errcode="${?}"
    if [ "${errcode}" -eq 0 ]; then
      warn "Successfully cached \"${key}\"."
    else
      case "${errcode}" in
        "${GPG_SIGN_FAIL}") warn "Gpg failed to sing with \"${key}\"." ;;
        "${GPG_ENC_FAIL}") warn "Gpg failed to encrypt with \"${key}\"." ;;
        "${GPG_DEC_FAIL}") warn "Gpg failed to decrypt with \"${key}\"." ;;
      esac
    fi

  done
}

main "${@}"
